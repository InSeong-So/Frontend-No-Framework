> 첫 번째 커밋때 추가한 부분
1. state - setState - render 기반 기능 구현

2. main.js는 ESM의 접근 파일(entry file)이므로 간략하게 만든다.

3. 컴포넌트 클래스를 작성하면 컴포넌트들을 조금 더 유연하게 만들 수 있다.
   - 컴포넌트 코드의 사용 방법을 강제하므로 코드를 유지보수하고 관리하기가 매우 수월하다.

> 두 번째 커밋때 추가한 부분
4. 불편하다!
   - Component의 render()가 실행되면 **이벤트가** 새로 등록된다. 또한 반복적인 요소에 이벤트를 등록해야 할 때도 너무 귀찮다.
   - 이벤트 버블링을 사용하자. 컴포넌트 자체에 이벤트를 등록하되, className별로 이벤트를 분기하여 처리하면 편해진다.
   - 이렇게 처리할 경우, render()마다 이벤트를 설정할 필요가 없어지므로 컴포넌트가 생성될 때 단 1회만 실행하도록 이벤트 사이클을 변경하도록 하자.

> 세 번째 커밋때 추가한 부분
5. 무슨 문제점이 있을지 고민해보자. 현재 코드는 컴포넌트를 분리할 필요가 없었지만, 다른 기능이 추가되면 어떨까?
   1. items의 상태를 확장해보자. `순번을 나타내는` **seq**, `내용을 나타내는` **contents**, `활성 여부를 나타내는` **active** 를 추가한다.
   2. 컴포넌트를 수정한다. addEventListner를 확장하는 형태로 작업할 수 있게끔 addEvent 함수를 추가한다.

6. 이제 Items 컴포넌트가 많은 일을 담당하게 되었다. 이 경우 생기는 문제점은 아래와 같다.
   1. 코드를 관리하기가 힘들다.
   2. 컴포넌트임에도 컴포넌트 단위로 활용할 수 없게 되었다.

7. 그럼 해결해야지? 컴포넌트는 기본적으로 `재활용`이 목적이다. 많은 일을 담당하는 컴포넌트를 잘개 쪼개어 최소한의 일을 수행하도록 분리해보자.

> 네 번째 커밋때 추가한 부분
8. 기능을 쪼갠다는 것은 컴포넌트가 담당할 책임을 분리하는 것이다. 그러기 위해선 상속받는 컴포넌트에 추가적인 프로퍼티를 정의할 필요가 있다.

9. 컴포넌트에 추가적인 요소를 정의했다면 이제 Item 컴포넌트의 기능을 분리해보자.
   - Item을 추가하는 기능
   - Item을 필터링하는 기능

10. 엔트리 포인트를 변경하고, `App` 을 총괄 창구로 수정한다.
   - 8번에서 수정한 props, mounted 프로퍼티를 사용하여 창구에서 정의한 함수를 thisdp 바인딩, 하위 컴포넌트에서 사용한다.